/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_DECODER_HPP
#define _EVENT_DECODER_HPP

#include "chainOfResponsability.hpp"
#include "cve5_generated.h"
#include "cve5_schema.h"
#include "eventContext.hpp"
#include "flatbuffers/idl.h"
#include "packageTranslation_generated.h"
#include "packageTranslation_schema.h"
#include "stringHelper.h"

/**
 * @brief EventDecoder class.
 *
 */
class EventDecoder final : public AbstractHandler<std::shared_ptr<EventContext>>
{
private:
    /**
     * @brief Process a CVE5 or Translation message.
     *
     * @param data Event context.
     */
    void processEvent(std::shared_ptr<EventContext> data)
    {
        if (data->resource.contains("resource"))
        {
            auto schema = cve5_SCHEMA;
            data->resourceType = RESOURCE_TYPE::CVE5;
            if (Utils::startsWith(data->resource.at("resource"), "TID-"))
            {
                schema = packageTranslation_SCHEMA;
                data->resourceType = RESOURCE_TYPE::TRANSLATION;
            }
            else if (!Utils::startsWith(data->resource.at("resource"), "CVE-"))
            {
                throw std::runtime_error("Invalid resource type.");
            }

            if ("create" == data->resource.at("type"))
            {
                flatbuffers::Parser parser;

                if (!parser.Parse(schema) || !parser.Parse(data->resource.at("payload").dump().c_str()))
                {
                    throw std::runtime_error("Unable to parse payload: " + parser.error_);
                }

                rocksdb::Slice flatbufferResource(reinterpret_cast<const char*>(parser.builder_.GetBufferPointer()),
                                                  parser.builder_.GetSize());
                if (RESOURCE_TYPE::CVE5 == data->resourceType)
                {
                    data->cvesDatabase->put(data->resource.at("resource"), flatbufferResource);

                    flatbuffers::FlatBufferBuilder& builder = parser.builder_;
                    data->cve5Buffer = builder.Release();
                }
                else
                {
                    data->translationsDatabase->put(data->resource.at("resource"), flatbufferResource);
                }
            }

            else if ("update" == data->resource.at("type"))
            {
                rocksdb::PinnableSlice slice;
                if (!data->cvesDatabase->get(data->resource.at("resource"), slice))
                {
                    throw std::runtime_error("Unable to find resource.");
                }

                flatbuffers::IDLOptions options;
                options.strict_json = true;
                flatbuffers::Parser parser(options);
                parser.Parse(schema);

                std::string strData;
                flatbuffers::GenText(parser, reinterpret_cast<const uint8_t*>(slice.data()), &strData);
                auto jsonData = nlohmann::json::parse(strData);

                jsonData.patch_inplace(data->resource.at("operations"));
                if (!parser.Parse(jsonData.dump().c_str()))
                {
                    throw std::runtime_error("Unable to parse patched data: " + parser.error_);
                }

                rocksdb::Slice flatbufferResource(reinterpret_cast<const char*>(parser.builder_.GetBufferPointer()),
                                                  parser.builder_.GetSize());
                if (RESOURCE_TYPE::CVE5 == data->resourceType)
                {
                    data->cvesDatabase->put(data->resource.at("resource"), flatbufferResource);

                    flatbuffers::FlatBufferBuilder& builder = parser.builder_;
                    data->cve5Buffer = builder.Release();
                }
                else
                {
                    data->translationsDatabase->put(data->resource.at("resource"), flatbufferResource);
                }
            }

            else if ("delete" == data->resource.at("type"))
            {
                if (RESOURCE_TYPE::CVE5 == data->resourceType)
                {
                    data->cvesDatabase->delete_(data->resource.at("resource"));
                }
                else
                {
                    data->translationsDatabase->delete_(data->resource.at("resource"));
                }
            }

            else
            {
                throw std::runtime_error("Unknown event type");
            }
        }
        else
        {
            throw std::runtime_error("Missing key 'resource'.");
        }
    }

public:
    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Event context.
     * @return std::shared_ptr<EventContext> Abstract handler.
     */
    std::shared_ptr<EventContext> handleRequest(std::shared_ptr<EventContext> data) override
    {
        processEvent(data);
        std::shared_ptr<EventContext> ret = nullptr;
        if (RESOURCE_TYPE::CVE5 == data->resourceType)
        {
            ret = AbstractHandler<std::shared_ptr<EventContext>>::handleRequest(data);
        }

        return ret;
    }
};

#endif // _EVENT_DECODER_HPP
