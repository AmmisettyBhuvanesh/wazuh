/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_DECODER_HPP
#define _EVENT_DECODER_HPP

#include "chainOfResponsability.hpp"
#include "cve5_generated.h"
#include "cve5_schema.h"
#include "eventContext.hpp"
#include "flatbuffers/idl.h"

/**
 * @brief EventDecoder class.
 *
 */
class EventDecoder final : public AbstractHandler<std::shared_ptr<EventContext>>
{
public:
    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    std::shared_ptr<EventContext> handleRequest(std::shared_ptr<EventContext> data) override
    {
        if ("create" == data->resource.at("type"))
        {
            flatbuffers::Parser parser;

            if (!parser.Parse(cve5_SCHEMA) || !parser.Parse(data->resource.at("payload").dump().c_str()))
            {
                throw std::runtime_error("Unable to parse payload: " + parser.error_);
            }

            rocksdb::Slice flatbufferResource(reinterpret_cast<const char*>(parser.builder_.GetBufferPointer()),
                                              parser.builder_.GetSize());
            data->cvesDatabase->put(data->resource.at("resource"), flatbufferResource);

            flatbuffers::FlatBufferBuilder& builder = parser.builder_;
            data->cve5Buffer = builder.Release();
        }

        else if ("update" == data->resource.at("type"))
        {
            rocksdb::PinnableSlice slice;
            if (!data->cvesDatabase->get(data->resource.at("resource"), slice))
            {
                throw std::runtime_error("Unable to find resource.");
            }

            flatbuffers::IDLOptions options;
            options.strict_json = true;
            flatbuffers::Parser parser(options);
            parser.Parse(cve5_SCHEMA);

            std::string strData;
            flatbuffers::GenText(parser, reinterpret_cast<const uint8_t*>(slice.data()), &strData);
            auto jsonData = nlohmann::json::parse(strData);

            jsonData.patch_inplace(data->resource.at("operations"));
            if (!parser.Parse(jsonData.dump().c_str()))
            {
                throw std::runtime_error("Unable to parse patched data: " + parser.error_);
            }

            rocksdb::Slice flatbufferResource(reinterpret_cast<const char*>(parser.builder_.GetBufferPointer()),
                                              parser.builder_.GetSize());
            data->cvesDatabase->put(data->resource.at("resource"), flatbufferResource);

            flatbuffers::FlatBufferBuilder& builder = parser.builder_;
            data->cve5Buffer = builder.Release();
        }

        else if ("delete" == data->resource.at("type"))
        {
            // CVE removal not supported.
        }

        else
        {
            throw std::runtime_error("Unknown event type");
        }

        return AbstractHandler<std::shared_ptr<EventContext>>::handleRequest(data);
    }
};

#endif // _EVENT_DECODER_HPP
