/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * Oct 3, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPDATE_CVE_DESCRIPTION_HPP
#define _UPDATE_CVE_DESCRIPTION_HPP

#include "chainOfResponsability.hpp"
#include "cve5_generated.h"
#include "eventContext.hpp"
#include "flatbuffers/flatbuffers.h"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityDescription_generated.h"

constexpr auto DESCRIPTION_DATABASE_PATH {"queue/vd/descriptions"};
constexpr auto CVE5_DATABASE_PATH {"queue/vd/cve5"};

/**
 * @brief UpdateCVEDescription class.
 *
 */
class UpdateCVEDescription final
{
public:
    /**
     * @brief Reads CVE5 database, creates a vulnerability description flatbuffer and stores it in a specific RocksDB
     * database.
     *
     * @param cve5Flatbuffer CVE5 Flatbuffer.
     * @param rocksDBWrapper rocksDB wrapper instance.
     */
    static void storeVulnerabilityDescription(const cve_v5::Entry* cve5Flatbuffer,
                                              Utils::RocksDBWrapper& rocksDBWrapper)
    {
        if (cve5Flatbuffer->containers() && cve5Flatbuffer->containers()->cna())
        {
            auto cna = cve5Flatbuffer->containers()->cna();
            // Missing metrics object is valid in a CVE5 schema.
            auto metricsArray = cna->metrics();
            auto descriptionArray = cna->descriptions();
            auto referencesArray = cna->references();

            float VulnDescFBScoreBase = 0.0;
            std::string VulnDescFBClassificationStr;
            std::string VulnDescFBDescriptionStr;
            std::string VulnDescFBSeverityStr;
            std::string VulnDescFBScoreVersionStr;
            std::string VulnDescFBReferenceStr;

            if (metricsArray)
            {
                for (const auto& field : *metricsArray)
                {
                    auto metricCVSSV3_1 = field->cvssV3_1();
                    auto metricCVSSV3_0 = field->cvssV3_0();
                    auto metricCVSSV2_0 = field->cvssV2_0();
                    if (metricCVSSV3_1)
                    {
                        VulnDescFBScoreBase = metricCVSSV3_1->baseScore();
                        auto baseSeverity = metricCVSSV3_1->baseSeverity();
                        VulnDescFBSeverityStr = (nullptr != baseSeverity) ? baseSeverity->str() : "";
                        auto version = metricCVSSV3_1->version();
                        VulnDescFBScoreVersionStr = (nullptr != version) ? version->str() : "";
                        auto format = field->format();
                        VulnDescFBClassificationStr = (nullptr != format) ? format->str() : "";
                        break;
                    }
                    else if (metricCVSSV3_0)
                    {
                        VulnDescFBScoreBase = metricCVSSV3_0->baseScore();
                        auto baseSeverity = metricCVSSV3_0->baseSeverity();
                        VulnDescFBSeverityStr = (nullptr != baseSeverity) ? baseSeverity->str() : "";
                        auto version = metricCVSSV3_0->version();
                        VulnDescFBScoreVersionStr = (nullptr != version) ? version->str() : "";
                        auto format = field->format();
                        VulnDescFBClassificationStr = (nullptr != format) ? format->str() : "";
                        break;
                    }
                    else if (metricCVSSV2_0)
                    {
                        VulnDescFBScoreBase = metricCVSSV2_0->baseScore();
                        VulnDescFBSeverityStr = (VulnDescFBScoreBase < 4.0)   ? "LOW"
                                                : (VulnDescFBScoreBase < 7.0) ? "MEDIUM"
                                                                              : "HIGH";
                        auto version = metricCVSSV2_0->version();
                        VulnDescFBScoreVersionStr = (nullptr != version) ? version->str() : "";
                        auto format = field->format();
                        VulnDescFBClassificationStr = (nullptr != format) ? format->str() : "";
                        break;
                    }
                }
            }

            if (descriptionArray)
            {
                for (const auto& field : *descriptionArray)
                {
                    if (field->lang()->str().compare("en") == 0)
                    {
                        VulnDescFBDescriptionStr = field->value()->str();
                        break;
                    }
                }
            }

            if (referencesArray)
            {
                for (const auto& field : *referencesArray)
                {
                    if (field->url())
                    {
                        VulnDescFBReferenceStr += field->url()->str();
                        VulnDescFBReferenceStr += ", ";
                    }
                }
            }

            VulnDescFBReferenceStr = VulnDescFBReferenceStr.substr(0, VulnDescFBReferenceStr.size() - 2);

            // Empty description or empty URL reference are not CVE5 Compliant.
            if (!(VulnDescFBDescriptionStr.empty() || VulnDescFBReferenceStr.empty()))
            {
                flatbuffers::FlatBufferBuilder builder;

                auto vulnerabilityDescriptionFB =
                    NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(builder,
                                                                                 VulnDescFBScoreBase,
                                                                                 VulnDescFBClassificationStr.c_str(),
                                                                                 VulnDescFBDescriptionStr.c_str(),
                                                                                 VulnDescFBSeverityStr.c_str(),
                                                                                 VulnDescFBScoreVersionStr.c_str(),
                                                                                 VulnDescFBReferenceStr.c_str());

                builder.Finish(vulnerabilityDescriptionFB);

                const uint8_t* buffer = builder.GetBufferPointer();
                size_t flatbufferSize = builder.GetSize();

                std::string key {cve5Flatbuffer->cveMetadata()->cveId()->str()};
                const rocksdb::Slice VulnerabilityDescriptionSlice(reinterpret_cast<const char*>(buffer),
                                                                   flatbufferSize);
                rocksDBWrapper.put(key, VulnerabilityDescriptionSlice);
            }
        }
    }

    /**
     * @brief Deletes a vulnerability description from the database.
     *
     * @param data Flatbuffer object containing the CVE information.
     * @param descriptionsDatabase Database of vulnerability descriptions.
     */
    static void removeVulnerabilityDescription(const cve_v5::Entry* data, Utils::RocksDBWrapper& descriptionsDatabase)
    {
        if (!data->cveMetadata() || !data->cveMetadata()->cveId())
        {
            return;
        }

        std::string key {data->cveMetadata()->cveId()->str()};
        descriptionsDatabase.delete_(key);
    }
};

#endif // _UPDATE_CVE_DESCRIPTION_HPP
