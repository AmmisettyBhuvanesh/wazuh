/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * Oct 6, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPDATE_CVE_CANDIDATES_HPP
#define _UPDATE_CVE_CANDIDATES_HPP

#include "cve5_generated.h"
#include "flatbuffers/flatbuffers.h"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityCandidate_generated.h"
#include <filesystem>

const std::unordered_map<std::string, NSVulnerabilityScanner::Status> VERSION_STATUS_MAP {
    {"unaffected", NSVulnerabilityScanner::Status::Status_unaffected},
    {"affected", NSVulnerabilityScanner::Status::Status_affected},
    {"unknown", NSVulnerabilityScanner::Status::Status_unknown}};

constexpr auto CANDIDATES_DATABASE_PATH {"queue/vd/candidates"};
constexpr auto CANDIDATES_CVE_COLUMN_NAME {"cveId"};

/**
 * @brief Helper class to centralize the map lookup and dynamic fill.
 *
 */
class CandidatesDBHelper final
{
public:
    /**
     * @brief Looks for the database in the map and adds it if it does not exist. In case of failIfNotExists, it throws
     * an exception if the database does not exist.
     *
     * @param shortName Name of the database.
     * @param map Candidates database map.
     * @param failIfNotExists Flag to indicate if it should throw an exception when the database does not exist.
     */
    void static findAndOpen(const std::string& shortName,
                            std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>>& map,
                            bool failIfNotExists = false)
    {
        if (map.find(shortName) == map.end())
        {
            std::string dbPath {CANDIDATES_DATABASE_PATH + std::string("/") + shortName};

            if (failIfNotExists)
            {
                if (!std::filesystem::exists(std::filesystem::path(dbPath)))
                {
                    throw std::runtime_error("Database " + dbPath + " does not exist");
                }
            }

            map.emplace(shortName,
                        std::make_unique<Utils::RocksDBWrapper>(
                            dbPath, std::vector<std::string>({CANDIDATES_CVE_COLUMN_NAME})));
        }
    }

    /**
     * @brief Reads the candidates DB directory and adds all the DBs found to the map.
     *
     * @param map All the candidates DBs will be stored in this map.
     */
    void static openAllDBs(std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>>& map)
    {
        if (std::filesystem::exists(std::filesystem::path(CANDIDATES_DATABASE_PATH)))
        {
            for (const auto& entry : std::filesystem::directory_iterator(CANDIDATES_DATABASE_PATH))
            {
                if (entry.is_directory())
                {
                    std::string shortName {entry.path().filename().string()};
                    findAndOpen(shortName, map);
                }
            }
        }
    }
};

/**
 * @brief UpdateCVECandidates class.
 *
 */
class UpdateCVECandidates final
{
public:
    /**
     * @brief Inserts the candidate data into the corresponding database.
     *
     * @param cve5Flatbuffer CVE5 Flatbuffer.
     * @param dbMap map with rocksDB instances.
     */
    static void storeVulnerabilityCandidate(const cve_v5::Entry* cve5Flatbuffer,
                                            std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>>& dbMap)
    {
        if (!cve5Flatbuffer || !cve5Flatbuffer->containers())
        {
            std::cerr << "Empty cve5Flatbuffer or containers.\n";
            return;
        }

        const auto cveId {cve5Flatbuffer->cveMetadata()->cveId()};

        auto candidateLambda = [&](const flatbuffers::Vector<::flatbuffers::Offset<cve_v5::Affected>>* affectedVector,
                                   const std::string& shortName)
        {
            std::unordered_map<
                std::string,
                std::pair<std::vector<flatbuffers::Offset<NSVulnerabilityScanner::ScanVulnerabilityCandidate>>,
                          flatbuffers::FlatBufferBuilder>>
                candidatesArraysMap;

            for (const auto& affected : *affectedVector)
            {
                if (!affected->product())
                {
                    std::cerr << "Empty product.\n";
                    continue;
                }

                if (candidatesArraysMap.find(affected->product()->str()) == candidatesArraysMap.end())
                {
                    candidatesArraysMap.emplace(
                        affected->product()->str(),
                        std::pair<std::vector<flatbuffers::Offset<NSVulnerabilityScanner::ScanVulnerabilityCandidate>>,
                                  flatbuffers::FlatBufferBuilder>());
                }

                auto& candidateBuilderRef = candidatesArraysMap.at(affected->product()->str()).second;

                // Versions array
                std::vector<flatbuffers::Offset<NSVulnerabilityScanner::Version>> versionFBArray;
                if (affected->versions())
                {
                    for (const auto& versionElement : *affected->versions())
                    {
                        NSVulnerabilityScanner::Status status;

                        if (versionElement->status() &&
                            VERSION_STATUS_MAP.find(versionElement->status()->str()) != VERSION_STATUS_MAP.end())
                        {
                            status = VERSION_STATUS_MAP.at(versionElement->status()->str());
                        }

                        auto versionFB = NSVulnerabilityScanner::CreateVersionDirect(
                            candidateBuilderRef,
                            status,
                            versionElement->version() ? versionElement->version()->c_str() : nullptr,
                            versionElement->lessThan() ? versionElement->lessThan()->c_str() : nullptr,
                            versionElement->lessThanOrEqual() ? versionElement->lessThanOrEqual()->c_str() : nullptr,
                            versionElement->versionType() ? versionElement->versionType()->c_str() : nullptr);

                        versionFBArray.push_back(versionFB);
                    }
                }

                // Platforms array
                std::vector<flatbuffers::Offset<flatbuffers::String>> platformsVec;
                if (affected->platforms())
                {
                    for (const auto& platform : *affected->platforms())
                    {
                        platformsVec.push_back(candidateBuilderRef.CreateString(platform->str()));
                    }
                }

                NSVulnerabilityScanner::Status defaultStatus;

                if (affected->defaultStatus() &&
                    VERSION_STATUS_MAP.find(affected->defaultStatus()->str()) != VERSION_STATUS_MAP.end())
                {
                    defaultStatus = VERSION_STATUS_MAP.at(affected->defaultStatus()->str());
                }

                auto candidate = NSVulnerabilityScanner::CreateScanVulnerabilityCandidateDirect(
                    candidateBuilderRef, cveId->c_str(), defaultStatus, &platformsVec, &versionFBArray);

                candidatesArraysMap.at(affected->product()->str()).first.push_back(candidate);
            }

            for (auto& [key, value] : candidatesArraysMap)
            {
                const auto finalArray =
                    NSVulnerabilityScanner::CreateScanVulnerabilityCandidateArrayDirect(value.second, &value.first);
                value.second.Finish(finalArray);

                const auto finalKey = key + "_" + cveId->str();
                const auto reverseKey = cveId->str() + "_" + key;

                // Inserting both entries in different column families in batch
                std::vector<std::tuple<std::string, std::string, rocksdb::Slice>> columnKeyValueVector {
                    {ROCKSDB_DEFAULT_COLUMN,
                     finalKey,
                     rocksdb::Slice(reinterpret_cast<const char*>(value.second.GetBufferPointer()),
                                    value.second.GetSize())},
                    {CANDIDATES_CVE_COLUMN_NAME, reverseKey, finalKey}};

                dbMap.at(shortName)->put(columnKeyValueVector);
            }
        };

        if (cve5Flatbuffer->containers()->adp())
        {
            for (const auto& adp : *cve5Flatbuffer->containers()->adp())
            {
                if (!adp->providerMetadata() || !adp->providerMetadata()->shortName() || !adp->affected())
                {
                    std::cerr << "Empty providerMetadata, shortName or affected.\n";
                    continue;
                }

                auto shortName = adp->providerMetadata()->shortName()->str();
                CandidatesDBHelper::findAndOpen(shortName, dbMap);

                candidateLambda(adp->affected(), shortName);
            }
        }

        if (cve5Flatbuffer->containers()->cna())
        {
            auto cna = cve5Flatbuffer->containers()->cna();

            if (!cna->affected())
            {
                return;
            }

            if (!cna->providerMetadata() || !cna->providerMetadata()->shortName())
            {
                std::cerr << "Empty providerMetadata or shortName.\n";
                return;
            }

            auto shortName = cna->providerMetadata()->shortName()->str();
            CandidatesDBHelper::findAndOpen(shortName, dbMap);

            candidateLambda(cna->affected(), shortName);
        }
    }

    /**
     * @brief Deletes all the candidates related to a CVE from all the databases.
     *
     * @param cve5Flatbuffer Flatbuffer object containing the CVE information.
     * @param dbMap Map with rocksdb instances.
     */
    static void removeVulnerabilityCandidate(const cve_v5::Entry* cve5Flatbuffer,
                                             std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>>& dbMap)
    {
        if (!cve5Flatbuffer->cveMetadata() || !cve5Flatbuffer->cveMetadata()->cveId())
        {
            return;
        }

        std::string cveId {cve5Flatbuffer->cveMetadata()->cveId()->str()};
        CandidatesDBHelper::openAllDBs(dbMap);

        for (const auto& [shortName, db] : dbMap)
        {
            std::vector<std::pair<std::string, std::string>> columnKeyVector;

            for (const auto& [key, value] : db->seek(CANDIDATES_CVE_COLUMN_NAME, cveId))
            {
                columnKeyVector.emplace_back(std::make_pair(ROCKSDB_DEFAULT_COLUMN, value.ToString()));
                columnKeyVector.emplace_back(std::make_pair(CANDIDATES_CVE_COLUMN_NAME, key));
            }

            if (!columnKeyVector.empty())
            {
                db->delete_(columnKeyVector);
            }
        }
    }
};

#endif // _UPDATE_CVE_CANDIDATES_HPP
