/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _STORE_MODEL_HPP
#define _STORE_MODEL_HPP

#include "chainOfResponsability.hpp"
#include "eventContext.hpp"
#include "storeRemediationsModel.hpp"
#include "updateCVECandidates.hpp"
#include "updateCVEDescription.hpp"
/**
 * @brief StoreModel class.
 *
 */
class StoreModel final : public AbstractHandler<std::shared_ptr<EventContext>>
{
public:
    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    std::shared_ptr<EventContext> handleRequest(std::shared_ptr<EventContext> data) override
    {
        if (!data->cve5Buffer.data())
        {
            throw std::runtime_error("CVE5 buffer is empty");
        }
        auto cve5Entry = cve_v5::GetEntry(data->cve5Buffer.data());
        auto type = data->resource.at("type").get<std::string>();
        auto state = cve5Entry->cveMetadata()
                         ? cve5Entry->cveMetadata()->state() ? cve5Entry->cveMetadata()->state()->str() : ""
                         : "";

        if ("update" == type)
        {
            // We clean the candidates DBs to keep the data synced
            UpdateCVECandidates::removeVulnerabilityCandidate(cve5Entry, m_feedsDatabases);
            if ("PUBLISHED" == state)
            {
                StoreRemediationsModel::updateRemediation(cve5Entry, m_remediationsDatabase);
                UpdateCVEDescription::storeVulnerabilityDescription(cve5Entry, m_descriptionsDatabase);
                UpdateCVECandidates::storeVulnerabilityCandidate(cve5Entry, m_feedsDatabases);
            }
            else if ("REJECTED" == state)
            {
                StoreRemediationsModel::removeRemediation(cve5Entry, m_remediationsDatabase);
                UpdateCVEDescription::removeVulnerabilityDescription(cve5Entry, m_descriptionsDatabase);
            }
        }
        else if ("create" == type)
        {
            if ("PUBLISHED" == state)
            {
                StoreRemediationsModel::updateRemediation(cve5Entry, m_remediationsDatabase);
                UpdateCVEDescription::storeVulnerabilityDescription(cve5Entry, m_descriptionsDatabase);
                UpdateCVECandidates::storeVulnerabilityCandidate(cve5Entry, m_feedsDatabases);
            }
            else if ("REJECTED" == state)
            {
            }
        }

        return AbstractHandler<std::shared_ptr<EventContext>>::handleRequest(data);
    }

    /**
     * @brief Constructor.
     *
     * @param vulnerabilitiesCandidates A map of vulnerability candidates databases.
     * @param vulnerabilityDescription A vulnerability description database.
     * @param vulnerabilityRemediations A remediations database.
     */
    explicit StoreModel(std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>>& vulnerabilitiesCandidates,
                        Utils::RocksDBWrapper* vulnerabilityDescription,
                        Utils::RocksDBWrapper* vulnerabilityRemediations)
        : m_feedsDatabases(vulnerabilitiesCandidates)
        , m_descriptionsDatabase(*vulnerabilityDescription)
        , m_remediationsDatabase(*vulnerabilityRemediations)
    {
        if (!vulnerabilityDescription)
        {
            throw std::runtime_error("Vulnerability description database is null");
        }

        if (!vulnerabilityRemediations)
        {
            throw std::runtime_error("Vulnerability remediations database is null");
        }
    }

private:
    Utils::RocksDBWrapper& m_descriptionsDatabase;
    Utils::RocksDBWrapper& m_remediationsDatabase;
    std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>>& m_feedsDatabases;
};

#endif // _STORE_MODEL_HPP
