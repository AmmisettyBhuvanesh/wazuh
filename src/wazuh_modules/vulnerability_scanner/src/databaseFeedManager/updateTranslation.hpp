/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPSERT_TRANSLATION_HPP
#define _UPSERT_TRANSLATION_HPP

#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "flatbuffers/util.h"
#include "json.hpp"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityTranslation_generated.h"
#include "vulnerabilityTranslation_schema.h"

constexpr auto TRANSLATION_DATABASE_PATH {"queue/vd/translations"};

/**
 * @brief UpdateTranslation class.
 *
 */
class UpdateTranslation final
{
private:
    /**
     * @brief Inserts a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void insertTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        std::string translationEntryStr;
        const std::string key = data.at("identifier").get_ref<const std::string&>();
        const std::string payload = data.dump();
        flatbuffers::Parser parser;

        if (!(parser.Parse(vulnerabilityTranslation_SCHEMA) && parser.Parse(payload.c_str())))
        {
            throw std::runtime_error(parser.error_);
        }
        else
        {
            const auto buf = parser.builder_.GetBufferPointer();
            const auto flatbufferSize = parser.builder_.GetSize();
            const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf), flatbufferSize);

            rocksDbWrapper.put(key, translationSlice);
        }
    }

public:
    /**
     * @brief Creates or modifies a translation entry in a rocksdb database.
     *
     * @param cve5Entry JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void updateTranslationEntry(const nlohmann::json& cve5Entry, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        if (cve5Entry.contains("containers") && cve5Entry.at("containers").contains("cna"))
        {
            auto cna = cve5Entry.at("containers").at("cna");
            if (cna.contains("x_translations"))
            {
                auto translations = cna.at("x_translations");
                for (const auto& item : translations)
                {
                    if (item.contains("identifier"))
                    {
                        auto key = item.at("identifier").get_ref<const std::string&>();
                        std::string translationEntryStr;
                        if (rocksDbWrapper.get(key, translationEntryStr))
                        {
                            flatbuffers::Parser parser;
                            parser.opts.strict_json = true;

                            if (!parser.Parse(vulnerabilityTranslation_SCHEMA))
                            {
                                throw std::runtime_error(parser.error_);
                            }
                            else
                            {
                                std::string translationEntry;
                                if (!flatbuffers::GenText(parser, translationEntryStr.c_str(), &translationEntry))
                                {
                                    try
                                    {
                                        nlohmann::json translationEntryJSON = nlohmann::json::parse(translationEntry);
                                        nlohmann::json patch = nlohmann::json::diff(translationEntryJSON, item);
                                        if (!patch.empty())
                                        {
                                            nlohmann::json translationEntryJSONPatched =
                                                translationEntryJSON.patch(patch);
                                            insertTranslationEntry(translationEntryJSONPatched, rocksDbWrapper);
                                        }
                                    }
                                    catch (...)
                                    {
                                        throw std::runtime_error("Couldn't patch data.");
                                    }
                                }
                                else
                                {
                                    throw std::runtime_error("Couldn't serialize data.");
                                }
                            }
                        }
                        else
                        {
                            insertTranslationEntry(item, rocksDbWrapper);
                        }
                    }
                    else
                    {
                        throw std::runtime_error(R"(Invalid format. Missing "identifier" key.)");
                    }
                }
            }
        }
        else
        {
            throw std::runtime_error("Invalid CVE5 format.");
        }
    }
};

#endif // _UPSERT_TRANSLATION_HPP
