/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPSERT_TRANSLATION_HPP
#define _UPSERT_TRANSLATION_HPP

#include "cve5_generated.h"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "flatbuffers/util.h"
#include "json.hpp"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityTranslation_generated.h"
#include "vulnerabilityTranslation_schema.h"

constexpr auto TRANSLATION_DATABASE_PATH {"queue/vd/translations"};

/**
 * @brief UpdateTranslation class.
 *
 */
class UpdateTranslation final
{
public:
    /**
     * @brief Creates or modifies a translation entry in a rocksdb database.
     *
     * @param cve5Entry CVE5 flatbuffer with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void updateTranslationEntry(const cve_v5::Entry* cve5Entry, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        if (cve5Entry->containers() && cve5Entry->containers()->cna())
        {
            auto cna = cve5Entry->containers()->cna();
            if (cna->x_translations())
            {
                auto translations = cna->x_translations();
                for (const auto& item : *translations)
                {
                    if (item->action() && item->source() && item->translation())
                    {
                        // Create action vector.
                        std::vector<int8_t> actionVector;
                        for (const auto& actionItem : *item->action())
                        {
                            actionVector.push_back(actionItem);
                        }

                        flatbuffers::FlatBufferBuilder translationFieldsBuilder;
                        flatbuffers::Offset<NSVulnerabilityScanner::TranslationFields> translationFieldsSource;

                        // Source builder.
                        translationFieldsSource = NSVulnerabilityScanner::CreateTranslationFieldsDirect(
                            translationFieldsBuilder,
                            item->source()->vendor() ? item->source()->vendor()->c_str() : nullptr,
                            item->source()->product() ? item->source()->product()->c_str() : nullptr,
                            item->source()->version() ? item->source()->version()->c_str() : nullptr);
                        translationFieldsBuilder.Finish(translationFieldsSource);

                        // translation builder vector
                        std::vector<flatbuffers::Offset<NSVulnerabilityScanner::TranslationFields>>
                            translationFieldsTranslationVector;
                        for (const auto& translationItem : *item->translation())
                        {
                            auto translationFieldsTranslation = NSVulnerabilityScanner::CreateTranslationFieldsDirect(
                                translationFieldsBuilder,
                                translationItem->vendor() ? translationItem->vendor()->c_str() : nullptr,
                                translationItem->product() ? translationItem->product()->c_str() : nullptr,
                                translationItem->version() ? translationItem->version()->c_str() : nullptr);
                            translationFieldsBuilder.Finish(translationFieldsTranslation);
                            translationFieldsTranslationVector.push_back(translationFieldsTranslation);
                        }

                        auto translationEntry = NSVulnerabilityScanner::CreateTranslationEntryDirect(
                            translationFieldsBuilder,
                            &actionVector,
                            item->identifier() ? item->identifier()->c_str() : nullptr,
                            translationFieldsSource,
                            item->target() ? item->target()->c_str() : nullptr,
                            &translationFieldsTranslationVector);

                        translationFieldsBuilder.Finish(translationEntry);

                        const uint8_t* TranslationEntryPointer = translationFieldsBuilder.GetBufferPointer();
                        const size_t TranslationEntrySize = translationFieldsBuilder.GetSize();

                        const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(TranslationEntryPointer),
                                                              TranslationEntrySize);
                        rocksDbWrapper.put(item->identifier()->c_str(), translationSlice);
                    }
                    else
                    {
                        throw std::runtime_error("Invalid format. Empty translation.");
                    }
                }
            }
        }
        else
        {
            throw std::runtime_error("Invalid CVE5 format.");
        }
    }
};

#endif // _UPSERT_TRANSLATION_HPP
